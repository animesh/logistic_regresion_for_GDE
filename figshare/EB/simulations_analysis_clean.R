########################################
## README:
##########
## This script does splatter simulations based either on default splatter parameters or parameters used by Nnatros et al, with modifications
## 1. The first part loads the Nnatros et al simulation
## 2. Then a list of splatter parameters is generated
## 3. We iterate over the list to  generate the simulated datasets
## 4. We downsample simulated datasets if relevant (to study the impact of dataset sizes, degree of confusion by batches...)
## 5. Then gene differential expression using MAST and multivariate LR is ran. The results are exported to disk
## 6. Finally, we plot results
########################################

library(rio)
library(biomaRt)
library(ebmisc)
library(Matrix)
library(MAST)
library(ggplot2)
library(scater)
library(ebmisc)
library(splatter)
library(gridExtra)
library(reshape)
library(grid)
library(RColorBrewer)
library(ggpubr)
library(patchwork)

options("mc.cores"=8)

setwd("~/ebecht_working/logistic_regression/figshare/EB/")

####################
## 1. Load and harmonize input
####################

## Load wrappers to run LR & MAST
source("~/ebecht_working/logistic_regression/wrappers.R")
## Adapted from: https://github.com/pachterlab/NYMP_2018/blob/master/simulations/RSEM/R/roc_helpers.R
source("~/ebecht_working/logistic_regression/NYMP_2018/simulations/RSEM/R/roc_helpers.R")

## Base dir for simulations
splatter_dir="~/ebecht_working/logistic_regression/figshare/splatter"
## Downloaded from: https://figshare.com/articles/Single_Cell_RNA-Seq_Simulations_for_Ntranos_Yi_et_al_2019/7108364
splat_authors=readRDS(file.path(splatter_dir,"splat.rds"))
## Downloaded from: https://figshare.com/articles/Single_Cell_RNA-Seq_Simulations_for_Ntranos_Yi_et_al_2019/7108364
splatter_tx=readRDS(file.path(splatter_dir,"counts.rds"))

## The splat_authors object is generated by splatter then subsetted so that cell populations (colData(splat_authors)$Group) are balanced (105 vs 105 cells). The following makes sure that the subsetting is done as per Nnatros et al.
rows=rownames(splatter_tx)
rownames(splat_authors)=rows
cols=colnames(splatter_tx)
splat_authors=splat_authors[,cols]
rm(splatter_tx)

## Extract splatter parameters as per Nnatros et al to perform further simulations with the same template
params=splat_authors@metadata$params
## Fix missing parameters from the template (likely due to splatter update at some point?)
attributes(params)$lib.norm=FALSE
attributes(params)$dropout.type="none"
attributes(params)$path.nSteps=1

## Get transcript to gene mapping
if(file.exists(file.path(splatter_dir,"t2g.rds"))){
    t2g=readRDS(file=file.path(splatter_dir,"t2g.rds"))
} else {
    mart=useDataset("hsapiens_gene_ensembl",useMart("ensembl"))
    t2g=getBM(attributes=c("ensembl_gene_id","ensembl_transcript_id"),values=rownames(splat),filters="ensembl_transcript_id",mart=mart)
    saveRDS(t2g,file=file.path(splatter_dir,"t2g.rds"))
}
## Remove transcripts without mapping and subset objects accordingly
annotated_transcripts=intersect(t2g[,"ensembl_transcript_id"],rows)
splat_authors=splat_authors[annotated_transcripts,]
splatter_t2g=setNames(t2g[,"ensembl_gene_id"],t2g[,"ensembl_transcript_id"])[annotated_transcripts]
rowData(splat_authors)=cbind(rowData(splat_authors),gene_ensembl=splatter_t2g)

####################
## 2. Set-up parameters for splatter simulations
####################

## Some documentation on splatter parameters:
## https://www.bioconductor.org/packages/devel/bioc/vignettes/splatter/inst/doc/splatter.html
## https://rdrr.io/github/Oshlack/splatter/man/SplatParams.html
simulations=list(
    list(
        name="vanilla",
        params=newSplatParams(nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5))
    ),
    list(
        name="vanilla_highES",
        params=newSplatParams(nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),de.facLoc=1.5)
    ),
    list(
        name="batch",
        params=newSplatParams(nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5))
    ),
    list(
        name="batch_highES",
        params=newSplatParams(nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5),de.facLoc=1.5)
    ),
    list(
        name="hibatch_highES",
        params=newSplatParams(nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5),de.facLoc=1.5,batch.facLoc=0.5)
    ),
    list(
        name="dropout",
        params=newSplatParams(nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),dropout.mid=c(3,6),dropout.shape=c(-0.4,-0.6),dropout.type="group")
    ),
    list(
        name="dropout_highES",
        params=newSplatParams(nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),dropout.mid=c(3,6),dropout.shape=c(-0.4,-0.6),dropout.type="group",de.facLoc=1.5)
    ),
    list(
        name="authors_batch",
        params=setParams(params,nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5))
    ),
    list(
        name="authors_batch_highES",
        params=setParams(params,nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5),de.facLoc=1.5)
    ),
    list(
        name="authors_hibatch_highES",
        params=setParams(params,nGenes=length(rows),batchCells=c(300,300),group.prob=c(0.5,0.5),de.facLoc=1.5,batch.facLoc=0.5)
    ),
    list(
        name="authors_dropout",
        params=setParams(params,nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),dropout.mid=c(3,6),dropout.shape=c(-0.4,-0.6),dropout.type="group")
    ),
    list(
        name="authors_dropout_highES",
        params=setParams(params,nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),dropout.mid=c(3,6),dropout.shape=c(-0.4,-0.6),dropout.type="group",de.facLoc=1.5)
    ),
    list(
        name="authors_highES",
        params=setParams(params,nGenes=length(rows),batchCells=300,group.prob=c(0.5,0.5),de.facLoc=1.5)
    )
)
names(simulations)=sapply(simulations,function(x){x$name})

####################
## 3. Simulation of datasets
####################

simulations=lapply(simulations,function(x){
    splat=splatSimulate(x[[2]],seed=123,method="group")
    rownames(splat)=rows
    splat=splat[annotated_transcripts,]
    x=c(x,list(splat=splat))
    x
})

##
## Adding authors' to the list of simulated datasets
##
simulations=c(
    list(
        authors=list(
            name="authors",
            params=params,
            splat=splat_authors,
            downsampling_matrix=matrix(nrow=1,ncol=2,dimnames=list("Batch1",paste0("Group",1:2)),data=c(105,105)),downsampling_indices=which(paste0("Cell",1:300)%in%colnames(splat_authors))
        )
    )
   ,simulations
)

##
## Computing tpms, cntxon...
##
simulations=lapply(simulations,function(x){
    splat=x$splat
    colData(splat)$cntxon=colSums(assays(splat)$counts>0) ##cntxon = Cellular Detection Rate (CDR) at the transcript level (see Finak et al, Genome Biology, 2015)
    rowData(splat)$transcript=rownames(rowData(splat)) ## Necessary for the do_mast_tx wrapper
    rowData(splat)$gene_ensembl=splatter_t2g[rownames(rowData(splat))] ## Necessary for the do_mast_tx wrapper
    assays(splat)$tpm=assays(splat)$count%*%diag(1/colSums(assays(splat)$count))*10^6 ## Computing TPMs
    rowData(splat)$expr_freq=rowMeans(assays(splat)$count>0)
    ## splat=splat[rowData(splat)$expr_freq>=0.2,]
    x$splat=splat
    x
})

####################
## 4. Downsampling simulations
####################

## Contingency tables for downsampling. Columns = Groups (cell populations) and Rows = Batches. Names of 1st level = current names, Names of 2nd level = name of downsampled element
downsampling=list(
    authors=list(
        authors=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    ),
    vanilla=list(
        vanilla=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE),
        vanilla10=matrix(nrow=1,ncol=2,data=c(10,10),byrow=TRUE),
        vanilla30=matrix(nrow=1,ncol=2,data=c(30,30),byrow=TRUE),
        vanilla50=matrix(nrow=1,ncol=2,data=c(50,50),byrow=TRUE)
    ),
    vanilla_highES=list(
        vanilla_highES=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE),
        vanilla_highES10=matrix(nrow=1,ncol=2,data=c(10,10),byrow=TRUE),
        vanilla_highES30=matrix(nrow=1,ncol=2,data=c(30,30),byrow=TRUE),
        vanilla_highES50=matrix(nrow=1,ncol=2,data=c(50,50),byrow=TRUE)
    ),
    batch=list(
        batch=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE)
    ),
    batch_highES=list(
        batch_highES=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE),
        batch_highES_moderateConfusion=matrix(nrow=2,ncol=2,data=c(40,65,65,40),byrow=TRUE),
        batch_highES_highConfusion=matrix(nrow=2,ncol=2,data=c(35,70,70,35),byrow=TRUE),
        batch_highES_50=matrix(nrow=2,ncol=2,data=c(15,10,10,15),byrow=TRUE)
    ),
    hibatch_highES=list(
        hibatch_highES=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE),
        hibatch_highES_moderateConfusion=matrix(nrow=2,ncol=2,data=c(40,65,65,40),byrow=TRUE),
        hibatch_highES_highConfusion=matrix(nrow=2,ncol=2,data=c(35,70,70,35),byrow=TRUE),
        hibatch_highES_50=matrix(nrow=2,ncol=2,data=c(15,10,10,15),byrow=TRUE)
    ),
    dropout=list(
        dropout=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    ),
    dropout_highES=list(
        dropout_highES=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    ),
    authors_batch=list(
        authors_batch=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE)
    ),
    authors_batch_highES=list(
        authors_batch_highES=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE),
        authors_batch_highES_moderateConfusion=matrix(nrow=2,ncol=2,data=c(40,65,65,40),byrow=TRUE),
        authors_batch_highES_highConfusion=matrix(nrow=2,ncol=2,data=c(35,70,70,35),byrow=TRUE),
        authors_batch_highES_50=matrix(nrow=2,ncol=2,data=c(15,10,10,15),byrow=TRUE)
    ),
    authors_hibatch_highES=list(
        authors_hibatch_highES=matrix(nrow=2,ncol=2,data=c(45,60,60,45),byrow=TRUE),
        authors_hibatch_highES_moderateConfusion=matrix(nrow=2,ncol=2,data=c(40,65,65,40),byrow=TRUE),
        authors_hibatch_highES_highConfusion=matrix(nrow=2,ncol=2,data=c(35,70,70,35),byrow=TRUE),
        authors_hibatch_highES_50=matrix(nrow=2,ncol=2,data=c(15,10,10,15),byrow=TRUE)
    ),
    authors_dropout=list(
        authors_dropout=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    ),
    authors_dropout_highES=list(
        authors_dropout_highES=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    ),
    authors_highES=list(
        authors_highES=matrix(nrow=1,ncol=2,data=c(105,105),byrow=TRUE)
    )
)

## Actual downsampling
simulations=lapply(
    names(downsampling),
    function(x){
        lapply(
            names(downsampling[[x]]),
            function(y){
                set.seed(234)
                dn_mat=downsampling[[x]][[y]]
                dimnames(dn_mat)=list(paste0("Batch",1:nrow(dn_mat)),paste0("Group",1:ncol(dn_mat)))
                colData=as.data.frame(colData(simulations[[x]]$splat),stringsAsFactors=FALSE)
                combs=as.data.frame(t(expand.grid(dimnames(dn_mat))),stringsAsFactors=FALSE)
                indices=lapply(combs,function(z){
                    sample(which(colData$Batch==z[1]&colData$Group==z[2]),size=dn_mat[z[1],z[2]])
                })
                indices=do.call(c,indices)
                res=simulations[[x]]
                res$splat=res$splat[,indices]
                res$downsampling_indices=unname(indices)
                res$downsampling_matrix=dn_mat
                res$name=y
                res$splat=res$splat[rowSums(assays(res$splat)$count)>0,]
                res
            }
        )
    }
)
simulations=do.call(c,simulations)

##
## Add gene-aggregated data
##
simulations=lapply(
    simulations,
    function(x){
        count=aggregate_df(assays(x$splat)$count,rowData(x$splat)$gene_ensembl,fun=sum,margin=1) ## Aggregate transcripts to gene counts by summation
        cData=colData(x$splat)
        fData=rowData(x$splat)
        fData=aggregate_df(as.matrix(fData)[,grepl("DEFacGroup",colnames(fData))],fData$gene_ensembl,fun=function(y){
            res=apply(!as.matrix(y)==1,2,any)
            mode(res)="numeric"
            res
        }) ## rowData only keeps track of whether the gene is differentially expressed (it is if any of its transcript is)
        fData=cbind(fData,gene_ensembl=rownames(fData),transcript=rownames(fData)) ## Necessary for the do_mast_tx wrapper
        splat_gn=FromMatrix(count,cData=cData,fData=as(fData,"DataFrame"),check_sanity=FALSE) ## Create the SingleCellAssay object
        names(assays(splat_gn))="counts"
        colData(splat_gn)$cntxon=colSums(assays(splat_gn)$counts>0) ##cntxon = Cellular Detection Rate (CDR) at the transcript level (see Finak et al, Genome Biology, 2015)
        rowData(splat_gn)$transcript=rownames(rowData(splat_gn))
        rowData(splat_gn)$gene_ensembl=rownames(rowData(splat_gn))
        assays(splat_gn)$tpm=assays(splat_gn)$count%*%diag(1/colSums(assays(splat_gn)$count))*10^6 ## compute TPMs
        x$splat_gn=splat_gn
        x
    }
)

##
## Output table with simulation parameters
## 
write.table(
    do.call(
        rbind,
        sapply(
            simulations,
            function(x){
                data.frame(
                    name=x$name,
                    template=ifelse(grepl("authors",x$name),"Authors","Vanilla"),
                    Group1Batch1=nrow(subset(colData(x$splat),Group=="Group1"&Batch=="Batch1")),
                    Group1Batch2=nrow(subset(colData(x$splat),Group=="Group1"&Batch=="Batch2")),
                    Group2Batch1=nrow(subset(colData(x$splat),Group=="Group2"&Batch=="Batch1")),
                    Group2Batch2=nrow(subset(colData(x$splat),Group=="Group2"&Batch=="Batch2")),
                    bath.facLoc=x$params@batch.facLoc,
                    dropout.type=x$params@dropout.type,
                    dropout.midrange=paste0(signif(x$params@dropout.mid,2),collapse=" / "),
                    dropout.shape=paste0(signif(x$params@dropout.shape,2),collapse=" / "),
                    DE.facLoc=paste0(x$params@de.facLoc,collapse=" / ")
                )
            },
            simplify=FALSE
        )
    ),
    file="../splatter/tables/simulations_parameters.csv",
    sep=",",
    row.names=FALSE
)

## Export all simulations
file=file.path(splatter_dir,"rds","simulations_pre_degs.rds")
saveRDS(simulations,file=file)

####################
## 5. Perform DEGs
####################
simulations=lapply(
    simulations,
    function(x){
        print(x$name)
        ## Only perform DEGs if result is missing from disk, otherwise load.
        file=file.path(splatter_dir,"rds",paste0(x$name,"_degs.rds"))
        if(!file.exists(file)){

            ##
            ## MAST
            ##
            fmla=if(length(unique(colData(x$splat)$Batch))>1){"~Group+Batch"}else{"~Group"} ## Model is (transcript counts ~ Group + Batch) if we simulate Batch, otherwise it is just (transcript ocunts ~ Group). We do not use cntxon as it is not informative in splatter so there is no reason to include it in the model
            mast_tpm=do_mast_tx(sca=FromMatrix(log2(1+assays(x$splat)$tpm),cData=colData(x$splat),fData=rowData(x$splat)),fmla=fmla,LRT="GroupGroup2") ## Generates MAST on transcripts + MAST-Sidak on genes
            mast_unaggregated_gn_tpm=do_mast_tx(sca=FromMatrix(log2(1+assays(x$splat_gn)$tpm),cData=colData(x$splat_gn),fData=rowData(x$splat_gn)),fmla=fmla,LRT="GroupGroup2") ## Generates MAST on gene counts


            ## Use Batch as covariate if relevant, NULL otherwise
            if(length(unique(colData(x$splat)[,"Batch",drop=TRUE]))>1){
                covariates=colData(x$splat)[,"Batch",drop=FALSE]
                covariates_aov=covariates[,1,drop=TRUE]
            } else {
                covariates=NULL
                covariates_aov=rep(1,ncol(x$splat))
            }

                        
            ##
            ## multivariate Logistic Regression
            ##
            lr_tpm=do_logreg(data=assays(x$splat)$tpm,response=colData(x$splat)$Group=="Group2",tx2gene=rowData(x$splat)$gene_ensembl,covariates=covariates) ## mLR on transcripts
            lr_unaggregated_tpm=do_logreg(data=assays(x$splat)$tpm,response=colData(x$splat)$Group=="Group2",tx2gene=rowData(x$splat)$transcript,covariates=covariates) ## univariate LR on transcripts
            lr_unaggregated_gn_tpm=do_logreg(data=assays(x$splat_gn)$tpm,response=colData(x$splat_gn)$Group=="Group2",tx2gene=rowData(x$splat_gn)$transcript,covariates=covariates) ## unvariate LR on gene counts

            ## ANOVA
            aov_tpm=do_t_tests(response=colData(x$splat)$Group,data=log2(1+assays(x$splat)$tpm),t2g=rowData(x$splat)$gene_ensembl,covariates=covariates_aov)
            aov_unaggregated_gn_tpm=do_t_tests(response=colData(x$splat_gn)$Group,data=log2(1+assays(x$splat_gn)$tpm),t2g=rowData(x$splat_gn)$gene_ensembl,covariates=covariates_aov)

            edgeRQLF_CDR = do_edgeRCDR(assays(x$splat)$tpm, colData(x$splat)$Group)
            edgeRQLF_CDR = list(
                tx = edgeRQLF_CDR,
                gn = sapply(
                    split(edgeRQLF_CDR, rowData(x$splat)[names(edgeRQLF_CDR),"gene_ensembl"]),
                    sidak
                )
            )
            edgeRQLF_CDR_gn = do_edgeRCDR(assays(x$splat_gn)$tpm, colData(x$splat_gn)$Group)
            
            limmatrend = do_limma(assays(x$splat)$tpm, colData(x$splat)$Group)                
            limmatrend = list(
                tx = limmatrend,
                gn = sapply(
                    split(limmatrend, rowData(x$splat)[names(limmatrend),"gene_ensembl"]),
                    sidak
                )
            )
            limmatrend_gn = do_limma(assays(x$splat_gn)$tpm, colData(x$splat_gn)$Group)                
            
            DESeq2 = do_DESeq2(assays(x$splat)$tpm, colData(x$splat)$Group)                
            DESeq2 = list(
                tx = DESeq2,
                gn = sapply(
                    split(DESeq2, rowData(x$splat)[names(DESeq2),"gene_ensembl"]),
                    sidak
                )
            )
            DESeq2_gn = do_DESeq2(assays(x$splat_gn)$tpm, colData(x$splat_gn)$Group)                
            
            rm(list=c("fmla","covariates","covariates_aov"))
            env=environment()
            ls=setdiff(ls(env=env),c("env","file","x"))
            degs=sapply(ls,get,env=env,simplify=FALSE)
            x=c(x,list(degs=degs))
            saveRDS(x,file=file)
            x
        } else {
            readRDS(file)
        }
    }
)

##
## Reformat DEGs (for consistency)
## 
simulations=lapply(
    simulations,
    function(x){
        degs=x$degs
        x$degs_formatted=list(
            mast_tx_sidak=degs$mast_tpm$gn,
            mast_tx_univ=degs$mast_tpm$tx,
            mast_gn_univ=degs$mast_unaggregated_gn_tpm$gn,
            lr_tx_multiv=degs$lr_tpm,
            lr_tx_univ=degs$lr_unaggregated_tpm,
            lr_gn_univ=degs$lr_unaggregated_gn_tpm,
            aov_tx_sidak=degs$aov_tpm$gn,
            aov_tx_univ=degs$aov_tpm$tx,
            aov_gn_univ=degs$aov_unaggregated_gn_tpm$gn,
            edgeRQLF_CDR_tx_sidak=degs$edgeRQLF_CDR$gn,
            edgeRQLF_CDR_tx_univ=degs$edgeRQLF_CDR$tx,
            edgeRQLF_CDR_gn_univ=degs$edgeRQLF_CDR_gn,
            edgeRQLF_tx_sidak=degs$edgeRQLF$gn,
            edgeRQLF_tx_univ=degs$edgeRQLF$tx,
            edgeRQLF_gn_univ=degs$edgeRQLF_gn,
            limmatrend_tx_sidak=degs$limmatrend$gn,
            limmatrend_tx_univ=degs$limmatrend$tx,
            limmatrend_gn_univ=degs$limmatrend_gn,
            DESeq2_tx_sidak=degs$DESeq2$gn,
            DESeq2_tx_univ=degs$DESeq2$tx,
            DESeq2_gn_univ=degs$DESeq2_gn
        )
        x
    }
)

if(FALSE){
####################
    ## 6. Plots
####################
    lapply(simulations,function(x){

        ## Compute which genes are differentially expressed (legacy, now also available in rowData(x$splat))
        print(x$name)
        de_transcripts=rowSums(as.matrix(rowData(x$splat)[,grepl("DEFacGroup",colnames(rowData(x$splat)))])!=1)>0
        de_genes=sapply(
            split_matrix(as.matrix(rowData(x$splat)),rowData(x$splat)$gene_ensembl),
            function(y){
                any(rowSums(as.matrix(y[,grepl("DEFacGroup",colnames(y))])!=1)>0)
            }
        )
        rowData(x$splat)=cbind(rowData(x$splat),de_transcript=de_transcripts)
        rowData(x$splat)=cbind(rowData(x$splat),de_gene=de_genes[rowData(x$splat)$gene_ensembl])
        rowData(x$splat_gn)=cbind(rowData(x$splat_gn),de_genes=de_genes[rowData(x$splat_gn)$gene_ensembl])

        ## Plot 10 randomly-selected differentially-expressed genes per simulation
        set.seed(345)
        file=file.path(splatter_dir,"graphs","genes_violin_plots",paste0(x$name,".pdf"))
        pdf(file)
        sapply(sample(names(de_genes[de_genes]),10),function(y){
            print(plot_gene(x$splat[rowData(x$splat)$gene_ensembl==y,]))
        })
        dev.off()

        ## Plot the distribution of p-values for each method
        file=file.path(splatter_dir,"graphs","pvalues_histogram",paste0(x$name,".pdf"))
        pdf(file)
        df=stack(x$degs_formatted)
        p=ggplot(data=df,aes(x=values))+
            geom_histogram(bins=20,aes(y=..density..),fill="gray")+
            theme_bw()+
            xlim(0,1)+
            facet_wrap(~ind,scales="free")
        print(p)
        dev.off()

        ## Generate 5-panel figures with 1) empirical FDR vs TPR [as per Nnatros et al], 2) FPR vs TPR [ROC curve], 3) nominal FDR (p-values from each GDE method + p.adjust(.,method="fdr") versus empirical FDR, 4) nominal FDR vs FPR and 5) nominal FDR vs sensitivity 
        file=file.path(splatter_dir,"graphs","roc_curves",paste0(x$name,".png"))
        png(file,width=6000,height=3000,res=300)
        fdrs=sapply(names(x$degs_formatted),function(y){
            if(grepl("ENSG",names(x$degs_formatted[[y]])[1])){
                true_DE=de_genes
            } else if (grepl("ENST",names(x$degs_formatted[[y]])[1])){
                true_DE=de_transcripts
            }
            calculate_fdr(true_DE=true_DE[names(x$degs_formatted[[y]])],pvalues=x$degs_formatted[[y]],title=y)
        },simplify=FALSE)
        fdrs <- lapply(1:length(fdrs), function(y) data.frame(sensitivity=fdrs[[y]]$sen, actual_FDR=fdrs[[y]]$fdr, FalsePositiveRate = fdrs[[y]]$FalsePositiveRate, nominal_FDR=p.adjust(fdrs[[y]]$pvalues,method="fdr"),Method = names(fdrs)[y]))
        fdrs <- do.call(rbind, fdrs)
        colors=setNames(makeTransparent(rep(brewer.pal(3,"Set1"),each=3),123),unique(fdrs$Method))
        linetype=setNames(rep(c("solid","dashed","dotted"),3),unique(fdrs$Method))
        p1 <- ggplot(data = fdrs, aes(x = actual_FDR , y = sensitivity, colour=Method, linetype=Method)) +
            scale_colour_manual(values=colors) +
            scale_linetype_manual(values=linetype) +
            geom_path() +
            theme_bw(12)
        p2 <- ggplot(data = fdrs, aes(x = FalsePositiveRate , y = sensitivity, colour=Method, linetype=Method)) +
            scale_colour_manual(values=colors) +
            scale_linetype_manual(values=linetype) +
            geom_path() +
            geom_abline(intercept=0,slope=1,linetype="dashed") +
            theme_bw(12)
        p3 <- ggplot(data = fdrs, aes(x = nominal_FDR , y = actual_FDR, colour=Method, linetype=Method)) +
            scale_colour_manual(values=colors) +
            scale_linetype_manual(values=linetype) +
            geom_path() +
            geom_vline(xintercept=0.05,linetype="dashed") +
            geom_abline(intercept=0,slope=1,linetype="dotted") +
            theme_bw(12)
        p4 <- ggplot(data = fdrs, aes(x = nominal_FDR, y = FalsePositiveRate, colour=Method, linetype=Method)) +
            scale_colour_manual(values=colors) +
            scale_linetype_manual(values=linetype) +
            geom_path() +
            geom_vline(xintercept=0.05,linetype="dashed") +
            theme_bw(12)
        p5 <- ggplot(data = fdrs, aes(x = nominal_FDR, y = sensitivity, colour=Method, linetype=Method)) +
            scale_colour_manual(values=colors) +
            scale_linetype_manual(values=linetype) +
            geom_path() +
            geom_vline(xintercept=0.05,linetype="dashed") +
            theme_bw(12)
        print(grid.arrange(p1,p2,grid.text(x$name),p3,p5,p4,ncol=3))
        
        dev.off()
    })

    ##
    ## Figure aggregating results from all the simulations
    ##

    all_sim=sapply(
        simulations,
        function(x){
            g=names(x$degs_formatted$lr_tx_multiv)
            de_genes=sapply(
                split_matrix(as.matrix(rowData(x$splat)),rowData(x$splat)$gene_ensembl),
                function(y){
                    any(rowSums(as.matrix(y[,grepl("DEFacGroup",colnames(y))])!=1)>0)
                }
            )
            TP_max=sum(de_genes)
            TN_max=sum(!de_genes)
            
            df=cbind(lr_tx_multiv=x$degs_formatted$lr_tx_multiv[g],mast_tx_sidak=x$degs_formatted$mast_tx_sidak[g],DE=de_genes[g])
            df=as.data.table(df)
            df=melt(df,measure.vars=c("lr_tx_multiv","mast_tx_sidak"),id.vars="DE")
            colnames(df)=c("DE","method","p")
            df[,simulation:=rep(x$name,nrow(df))]
            df=split(df,as.character(df$method))

            ## For each possible p-value threshold, tabulate TPR, FPR, fraction of genes considered GDE
            df=lapply(df,function(y){
                y[,q:=p.adjust(p,method="fdr")]
                y[,n:=nrow(.SD),by=p]

                y[,sens:=sum(.SD$DE),by=p]
                y[,FPR:=sum(!.SD$DE),by=p]
                setorder(y,p)
                y=y[!duplicated(p),]
                y=y[,n:=cumsum(y$n)]
                y=y[,sens:=cumsum(y$sens)/TP_max]
                y=y[,FPR:=cumsum(y$FPR)/TN_max]
                y[,n:=n/max(n)]
                y
            })
            df=do.call(rbind,df)
            df
        },simplify=FALSE
    )
    all_sim=do.call(rbind,all_sim)
    all_sim[,method:=as.character(all_sim$method)]

    all_sim=subset(all_sim,!grepl("dropout",all_sim$simulation)) ## While we simulate with dropout being differential across cell subgroups, it does not make sense to compute the statistics we compute in this case. Indeed, differential dropout is computed for each gene independently of whether the gene is differentially expressed or not, which is arguably wrong.

    ##
    ## Plot nominal FDR vs Sensitivity and nominal FDR vs FPR (for all simulations, in distinct panels)
    ##

    methods=unique(all_sim$method)
    colors=setNames(c("red","blue"),methods)
    linetype=setNames(rep("solid",2),methods)

    p1=ggplot(data=all_sim,aes(x=q, y=sens, group=method, colour=method)) +
        geom_path(size=1) +
        scale_colour_manual(values=colors) +
        scale_linetype_manual(values=linetype) +
        xlab("Q") +
        ylab("Sensitivity")+
        theme_bw() +
        ggtitle("Sensitivity") +
        xlim(0,1) +
        facet_wrap(~simulation)

    p2=ggplot(data=all_sim,aes(x=q, y=FPR, group=method, colour=method, linetype=method)) +
        geom_path(size=1) +
        scale_colour_manual(values=colors) +
        scale_linetype_manual(values=linetype) +
        xlab("Q") +
        ylab("False Positive Rate")+
        theme_bw() +
        ggtitle("False Positive Rate") +
        xlim(0,1) +
        facet_wrap(~simulation)

    file=file.path(splatter_dir,"graphs","paper_roc_curves_all_faceted.png")
    png(file,width=8000,height=4000,res=300)
    p1+p2
    dev.off()

    ##
    ## Plot nominal FDR vs Sensitivity and nominal FDR vs FPR (in two panels only)
    ##

    interp_points=seq(0,1,by=0.01)
    all_sim_interp=split(all_sim,paste0(all_sim$simulation,all_sim$method))
    all_sim_interp=lapply(all_sim_interp,function(x){
        res=data.table(p=interp_points)
        res[,sens:=approx(x=x$p,y=x$sens,xout=interp_points)$y] ## Linear interpolation on a common set of points for future pairwise plotting
        res[,FPR:=approx(x=x$p,y=x$FPR,xout=interp_points)$y]
        res[p==0,c("sens","FPR"):=c(0,0)]
        res[p==1,c("sens","FPR"):=c(1,1)]
        res[,method:=rep(x$method[1],nrow(res))]
        res[,simulation:=rep(x$simulation[1],nrow(res))]
        res
    })

    all_sim_interp=do.call(rbind,all_sim_interp)
    all_sim_interp=split(all_sim_interp,all_sim_interp$simulation)
    all_sim_interp=lapply(all_sim_interp,function(x){
        d1=x[method=="lr_tx_multiv",]
        d2=x[method=="mast_tx_sidak",]
        res=d1[,method:="difference"]
        res[,sens:=unlist(d1$sens)-unlist(d2$sens)]
        res[,FPR:=unlist(d1$FPR)-unlist(d2$FPR)]
        res
    })

    all_sim_interp=do.call(rbind,all_sim_interp)

    ytop=max(c(all_sim_interp$sens,all_sim_interp$FPR))
    p1=ggplot(data=all_sim_interp,aes(x=p,y=sens,colour=simulation)) +
        geom_path(size=1) +
        xlab("P") +
        ylab("Sensitivity_mLR - Sensitivity_MAST") +
        theme_bw() +
        xlim(0,1) +
        ## facet_wrap(~simulation) +
        ylim(-0.2,ytop) +
        geom_hline(yintercept=0,linetype="dashed") +
        ggtitle("Sensitivity")

    p2=ggplot(data=all_sim_interp,aes(x=p,y=FPR,colour=simulation)) +
        geom_path(size=1) +
        xlab("P") +
        ylab("FPR_mLR - FPR_MAST") +
        theme_bw() +
        ylim(-0.2,ytop) +
        ## facet_wrap(~simulation) +
        xlim(-0,1) +
        geom_hline(yintercept=0,linetype="dashed") +
        ggtitle("FPR")

    file=file.path(splatter_dir,"graphs","paper_roc_curves_all_aggregated.png")
    png(file,width=6000,height=2000,res=300)
    p1+p2
    dev.off()
}
